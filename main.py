import asyncio
import os
import logging
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple, Set
import aiohttp
import json
from dataclasses import dataclass
from enum import Enum

# Telegram Bot
import telegram
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, ContextTypes

# Tinkoff Invest API
from tinkoff.invest import Client, RequestError, MarketDataRequest, GetCandlesRequest
from tinkoff.invest.schemas import CandleInterval, Instrument
from tinkoff.invest.utils import now

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class Signal:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞"""
    symbol: str
    entry_price: float
    stop_loss: float
    take_profit_1: float
    take_profit_2: float
    take_profit_3: float
    signal_time: datetime
    setup_description: str
    risk_reward_1: float
    risk_reward_2: float
    risk_reward_3: float
    local_high: float  # –î–æ–±–∞–≤–ª—è–µ–º –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∞–∫—Å–∏–º—É–º–∞
    local_low: float   # –î–æ–±–∞–≤–ª—è–µ–º –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∏–Ω–∏–º—É–º–∞

class SignalStatus(Enum):
    WAITING = "waiting"
    TRIGGERED = "triggered"
    CLOSED = "closed"

# –¢–æ–ø-10 –∞–∫—Ü–∏–π –ú–æ—Å–±–∏—Ä–∂–∏ (—Ç–∏–∫–µ—Ä—ã –¥–ª—è Tinkoff API)
TOP_MOEX_STOCKS = [
    "SBER",    # –°–±–µ—Ä–±–∞–Ω–∫
    "GAZP",    # –ì–∞–∑–ø—Ä–æ–º
    "LKOH",    # –õ–£–ö–û–ô–õ
    "YNDX",    # –Ø–Ω–¥–µ–∫—Å
    "GMKN",    # –ì–ú–ö –ù–æ—Ä–∏–ª—å—Å–∫–∏–π –Ω–∏–∫–µ–ª—å
    "NVTK",    # –ù–æ–≤–∞—Ç—ç–∫
    "ROSN",    # –†–æ—Å–Ω–µ—Ñ—Ç—å
    "MTSS",    # –ú–¢–°
    "MGNT",    # –ú–∞–≥–Ω–∏—Ç
    "PLZL"     # –ü–æ–ª—é—Å
]

class TradingBot:
    def __init__(self):
        self.tinkoff_token = os.getenv('TINKOFF_TOKEN')
        self.telegram_token = os.getenv('TELEGRAM_BOT_TOKEN')
        
        self.application = Application.builder().token(self.telegram_token).build()
        self.active_signals: Dict[str, Signal] = {}
        self.instruments_cache: Dict[str, str] = {}  # ticker -> figi
        self.subscribers: Set[int] = set()  # –ü–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        self.start_time = datetime.now()
        
        # –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–±–æ–µ–≤ EMA –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
        self.ema_breakouts: Dict[str, dict] = {}  # ticker -> {'time': datetime, 'price': float}
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("subscribe", self.subscribe_command))
        self.application.add_handler(CommandHandler("unsubscribe", self.unsubscribe_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("signals", self.signals_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("stats", self.stats_command))

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        welcome_message = """
ü§ñ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Trading Bot!</b>

–Ø –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ç–æ–ø-10 –∞–∫—Ü–∏–π –ú–æ—Å–±–∏—Ä–∂–∏ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è—é —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã –ø–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø—Ä–æ–±–æ—è EMA33.

<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>
/start - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
/subscribe - –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —Å–∏–≥–Ω–∞–ª—ã
/unsubscribe - –û—Ç–ø–∏—Å–∞—Ç—å—Å—è –æ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤
/status - –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
/signals - –ü–æ–∫–∞–∑–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã
/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
/help - –ü–æ–¥—Ä–æ–±–Ω–∞—è –ø–æ–º–æ—â—å

<b>–î–ª—è –Ω–∞—á–∞–ª–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:</b> /subscribe
        """
        await update.message.reply_text(welcome_message, parse_mode='HTML')

    async def subscribe_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–∏–≥–Ω–∞–ª—ã"""
        user_id = update.effective_user.id
        if user_id not in self.subscribers:
            self.subscribers.add(user_id)
            await update.message.reply_text(
                "‚úÖ <b>–í—ã –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã!</b>\n\n"
                "–¢–µ–ø–µ—Ä—å –≤—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–∞—Ö –∏ –∏—Ö —Å—Ç–∞—Ç—É—Å–µ.",
                parse_mode='HTML'
            )
            logger.info(f"–ù–æ–≤—ã–π –ø–æ–¥–ø–∏—Å—á–∏–∫: {user_id}")
        else:
            await update.message.reply_text("‚ÑπÔ∏è –í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Å–∏–≥–Ω–∞–ª—ã.")

    async def unsubscribe_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û—Ç–ø–∏—Å–∫–∞ –æ—Ç —Å–∏–≥–Ω–∞–ª–æ–≤"""
        user_id = update.effective_user.id
        if user_id in self.subscribers:
            self.subscribers.remove(user_id)
            await update.message.reply_text("‚ùå <b>–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤.</b>", parse_mode='HTML')
            logger.info(f"–û—Ç–ø–∏—Å–∞–ª—Å—è: {user_id}")
        else:
            await update.message.reply_text("‚ÑπÔ∏è –í—ã –Ω–µ –±—ã–ª–∏ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Å–∏–≥–Ω–∞–ª—ã.")

    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞"""
        active_signals_count = len(self.active_signals)
        subscribers_count = len(self.subscribers)
        uptime = datetime.now() - self.start_time
        tracking_count = len(self.ema_breakouts)
        
        status_message = f"""
üìä <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞:</b>

üë• <b>–ü–æ–¥–ø–∏—Å—á–∏–∫–æ–≤:</b> {subscribers_count}
üö® <b>–ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤:</b> {active_signals_count}
üìç <b>–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã—Ö –ø—Ä–æ–±–æ–µ–≤:</b> {tracking_count}
‚è∞ <b>–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã:</b> {str(uptime).split('.')[0]}
üìà <b>–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∞–∫—Ü–∏–∏:</b> {len(TOP_MOEX_STOCKS)}

<b>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã:</b> {', '.join(TOP_MOEX_STOCKS)}
        """
        await update.message.reply_text(status_message, parse_mode='HTML')

    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–±–æ–µ–≤"""
        if not self.ema_breakouts:
            await update.message.reply_text("üìä <b>–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–π –ø—Ä–æ–±–æ–µ–≤ EMA33.</b>", parse_mode='HTML')
            return
            
        message = "üìä <b>–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –ø—Ä–æ–±–æ–∏ EMA33:</b>\n\n"
        for ticker, breakout_info in self.ema_breakouts.items():
            time_passed = datetime.now() - breakout_info['time']
            hours = time_passed.seconds // 3600
            minutes = (time_passed.seconds % 3600) // 60
            
            message += f"‚Ä¢ <b>{ticker}</b>\n"
            message += f"  –ü—Ä–æ–±–æ–π: {breakout_info['price']:.2f} ‚ÇΩ\n"
            message += f"  –í—Ä–µ–º—è: {hours}—á {minutes}–º –Ω–∞–∑–∞–¥\n"
            if 'local_high' in breakout_info:
                message += f"  –ú–∞–∫—Å: {breakout_info['local_high']:.2f} ‚ÇΩ\n"
            if 'local_low' in breakout_info:
                message += f"  –ú–∏–Ω: {breakout_info['local_low']:.2f} ‚ÇΩ\n"
            message += "\n"
            
        await update.message.reply_text(message, parse_mode='HTML')

    async def signals_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã"""
        if not self.active_signals:
            await update.message.reply_text("üì≠ <b>–ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–µ—Ç.</b>", parse_mode='HTML')
            return

        message = "üîî <b>–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã:</b>\n\n"
        for ticker, signal in self.active_signals.items():
            age = datetime.now() - signal.signal_time
            message += f"üìä <b>{ticker}</b>\n"
            message += f"üí∞ –í—Ö–æ–¥: {signal.entry_price:.2f} ‚ÇΩ\n"
            message += f"üõë SL: {signal.stop_loss:.2f} ‚ÇΩ\n"
            message += f"‚è∞ {age.seconds//3600}—á {(age.seconds//60)%60}–º –Ω–∞–∑–∞–¥\n\n"

        await update.message.reply_text(message, parse_mode='HTML')

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–¥—Ä–æ–±–Ω–∞—è –ø–æ–º–æ—â—å"""
        help_message = """
üìö <b>–ü–æ–¥—Ä–æ–±–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ—Ç–µ</b>

<b>üéØ –£–ª—É—á—à–µ–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏:</b>
1. –û—Ç—Å–∫–æ–∫ –æ—Ç —É—Ä–æ–≤–Ω—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏
2. –ü—Ä–æ–±–æ–π EMA33 –≤–≤–µ—Ä—Ö
3. –û–∂–∏–¥–∞–Ω–∏–µ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∞–∫—Å–∏–º—É–º–∞
4. –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∏–Ω–∏–º—É–º–∞ (—Ä–µ—Ç–µ—Å—Ç)
5. –û—Ç–ª–æ–∂–µ–Ω–Ω—ã–π –æ—Ä–¥–µ—Ä –Ω–∞ –ø—Ä–æ–±–æ–π –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∞–∫—Å–∏–º—É–º–∞

<b>‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:</b>
‚Ä¢ –í—Ä–µ–º—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ—Å–ª–µ –ø—Ä–æ–±–æ—è: –¥–æ 48 —á–∞—Å–æ–≤
‚Ä¢ –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ —Ä–µ—Ç–µ—Å—Ç–∞ –æ—Ç EMA33: –¥–æ 2%
‚Ä¢ –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω—ã—Ö —ç–∫—Å—Ç—Ä–µ–º—É–º–æ–≤: 0.3%

<b>üìä –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–µ–π:</b>
‚Ä¢ TP1 (1/3): –ü—Ä–∏ R/R 1:1 ‚Üí SL –≤ –±–µ–∑—É–±—ã—Ç–æ–∫
‚Ä¢ TP2 (1/3): –ü—Ä–∏ R/R 1:2 ‚Üí SL –Ω–∞ —É—Ä–æ–≤–µ–Ω—å TP1
‚Ä¢ TP3 (1/3): –ü—Ä–∏ R/R 1:3 ‚Üí –ø–æ–ª–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ

<b>‚è∞ –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã:</b>
‚Ä¢ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ: –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
‚Ä¢ –¢–æ—Ä–≥–æ–≤–æ–µ –≤—Ä–µ–º—è: 10:00-18:30 –ú–°–ö
‚Ä¢ –¢–∞–π–º—Ñ—Ä–µ–π–º: 1 —á–∞—Å

<b>üìà –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ –∞–∫—Ü–∏–∏:</b>
SBER, GAZP, LKOH, YNDX, GMKN, NVTK, ROSN, MTSS, MGNT, PLZL

<b>‚ö†Ô∏è –í–∞–∂–Ω–æ:</b>
–ë–æ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞. –í—Å–µ —Ç–æ—Ä–≥–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è –≤—ã –ø—Ä–∏–Ω–∏–º–∞–µ—Ç–µ —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ!
        """
        await update.message.reply_text(help_message, parse_mode='HTML')

    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
        try:
            async with Client(self.tinkoff_token) as client:
                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö
                instruments = await client.instruments.shares()
                for instrument in instruments.instruments:
                    if instrument.ticker in TOP_MOEX_STOCKS:
                        self.instruments_cache[instrument.ticker] = instrument.figi
                        
            logger.info(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–∞–π–¥–µ–Ω–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤: {len(self.instruments_cache)}")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")

    async def broadcast_message(self, message: str):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å–µ–º –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º"""
        if not self.subscribers:
            return
            
        failed_sends = []
        for chat_id in self.subscribers.copy():
            try:
                await self.application.bot.send_message(
                    chat_id=chat_id,
                    text=message,
                    parse_mode='HTML'
                )
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ {chat_id}: {e}")
                failed_sends.append(chat_id)
                
        # –£–¥–∞–ª—è–µ–º –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        for chat_id in failed_sends:
            self.subscribers.discard(chat_id)

    async def get_candles(self, figi: str, interval: CandleInterval, days: int = 2) -> pd.DataFrame:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        try:
            async with Client(self.tinkoff_token) as client:
                from_time = now() - timedelta(days=days)
                to_time = now()
                
                request = GetCandlesRequest(
                    figi=figi,
                    from_=from_time,
                    to=to_time,
                    interval=interval
                )
                
                candles = await client.market_data.get_candles(request=request)
                
                data = []
                for candle in candles.candles:
                    data.append({
                        'time': candle.time,
                        'open': float(candle.open.units + candle.open.nano / 1e9),
                        'high': float(candle.high.units + candle.high.nano / 1e9),
                        'low': float(candle.low.units + candle.low.nano / 1e9),
                        'close': float(candle.close.units + candle.close.nano / 1e9),
                        'volume': candle.volume
                    })
                
                df = pd.DataFrame(data)
                if not df.empty:
                    df['time'] = pd.to_datetime(df['time'])
                    df = df.set_index('time')
                    
                return df
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {figi}: {e}")
            return pd.DataFrame()

    def calculate_ema(self, prices: pd.Series, period: int) -> pd.Series:
        """–†–∞—Å—á–µ—Ç —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π —Å–∫–æ–ª—å–∑—è—â–µ–π —Å—Ä–µ–¥–Ω–µ–π"""
        return prices.ewm(span=period).mean()

    def find_local_extremes(self, df: pd.DataFrame, window: int = 3) -> Tuple[List[float], List[float]]:
        """–ü–æ–∏—Å–∫ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –º–∞–∫—Å–∏–º—É–º–æ–≤ –∏ –º–∏–Ω–∏–º—É–º–æ–≤"""
        highs = []
        lows = []
        
        for i in range(window, len(df) - window):
            # –õ–æ–∫–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º
            if df['high'].iloc[i] == df['high'].iloc[i-window:i+window+1].max():
                highs.append((i, df['high'].iloc[i]))
            
            # –õ–æ–∫–∞–ª—å–Ω—ã–π –º–∏–Ω–∏–º—É–º
            if df['low'].iloc[i] == df['low'].iloc[i-window:i+window+1].min():
                lows.append((i, df['low'].iloc[i]))
                
        return highs, lows

    def detect_ema_breakout(self, df: pd.DataFrame, ema_period: int = 33) -> Optional[dict]:
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –ø—Ä–æ–±–æ—è EMA33 –≤–≤–µ—Ä—Ö"""
        if len(df) < ema_period + 5:
            return None
            
        df['ema33'] = self.calculate_ema(df['close'], ema_period)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–≤–µ—á–µ–π –Ω–∞ –ø—Ä–æ–±–æ–π (—É–≤–µ–ª–∏—á–µ–Ω–æ —Å 5)
        for i in range(-10, 0):
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ–±–æ–π: –ø—Ä–µ–¥—ã–¥—É—â–∞—è —Å–≤–µ—á–∞ –∑–∞–∫—Ä—ã–ª–∞—Å—å –Ω–∏–∂–µ EMA, —Ç–µ–∫—É—â–∞—è –≤—ã—à–µ
                if (df.iloc[i-1]['close'] <= df.iloc[i-1]['ema33'] and 
                    df.iloc[i]['close'] > df.iloc[i]['ema33'] and
                    df.iloc[i]['volume'] > df['volume'].iloc[i-10:i].mean() * 1.2):  # –û–±—ä–µ–º –≤—ã—à–µ —Å—Ä–µ–¥–Ω–µ–≥–æ –Ω–∞ 20%
                    
                    return {
                        'index': len(df) + i,
                        'time': df.index[i],
                        'price': df.iloc[i]['close'],
                        'ema_value': df.iloc[i]['ema33']
                    }
            except:
                continue
                
        return None

    def check_setup_formation(self, df: pd.DataFrame, breakout_info: dict) -> Optional[dict]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å–µ—Ç–∞–ø–∞ –ø–æ—Å–ª–µ –ø—Ä–æ–±–æ—è EMA33"""
        try:
            if not breakout_info:
                return None
                
            breakout_index = breakout_info['index']
            
            # –ë–µ—Ä–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –ø—Ä–æ–±–æ—è
            post_breakout_df = df.iloc[breakout_index:]
            
            if len(post_breakout_df) < 5:  # –ú–∏–Ω–∏–º—É–º 5 —Å–≤–µ—á–µ–π –ø–æ—Å–ª–µ –ø—Ä–æ–±–æ—è
                return None
                
            # –†–∞—Å—á–∏—Ç—ã–≤–∞–µ–º EMA –¥–ª—è —ç—Ç–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞
            post_breakout_df['ema33'] = self.calculate_ema(df['close'], 33).iloc[breakout_index:]
            
            # –ò—â–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã
            highs, lows = self.find_local_extremes(post_breakout_df, window=2)
            
            if not highs or not lows:
                return None
                
            # –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–≤—ã–π –∑–Ω–∞—á–∏–º—ã–π –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º (–º–∏–Ω–∏–º—É–º 0.3% –æ—Ç —Ü–µ–Ω—ã –ø—Ä–æ–±–æ—è)
            local_high = None
            for idx, high_price in highs:
                if high_price > breakout_info['price'] * 1.003:  # –ú–∏–Ω–∏–º—É–º 0.3% –≤—ã—à–µ
                    local_high = high_price
                    local_high_idx = idx
                    break
                    
            if not local_high:
                return None
                
            # –ò—â–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∏–Ω–∏–º—É–º –ø–æ—Å–ª–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∞–∫—Å–∏–º—É–º–∞
            local_low = None
            local_low_idx = None
            for idx, low_price in lows:
                if idx > local_high_idx:  # –ú–∏–Ω–∏–º—É–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø–æ—Å–ª–µ –º–∞–∫—Å–∏–º—É–º–∞
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç EMA33 (—É–≤–µ–ª–∏—á–µ–Ω–æ –¥–æ 2%)
                    ema_at_low = post_breakout_df['ema33'].iloc[idx]
                    distance_to_ema = abs(low_price - ema_at_low) / ema_at_low
                    
                    if distance_to_ema <= 0.02:  # –í –ø—Ä–µ–¥–µ–ª–∞—Ö 2% –æ—Ç EMA33
                        local_low = low_price
                        local_low_idx = idx
                        break
                        
            if not local_low:
                return None
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º–∏–Ω–∏–º—É–º –≤—ã—à–µ EMA33 (–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏)
            if local_low < post_breakout_df['ema33'].iloc[local_low_idx] * 0.995:  # –î–æ–ø—É—Å–∫ 0.5%
                return None
                
            return {
                'local_high': local_high,
                'local_low': local_low,
                'ema_at_low': post_breakout_df['ema33'].iloc[local_low_idx],
                'current_price': df['close'].iloc[-1]
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Å–µ—Ç–∞–ø–∞: {e}")
            return None

    def generate_signal(self, ticker: str, setup_info: dict) -> Signal:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞"""
        # –í—Ö–æ–¥ - –ø—Ä–æ–±–æ–π –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –º–∞–∫—Å–∏–º—É–º–∞
        entry_price = setup_info['local_high'] + (setup_info['local_high'] * 0.001)  # +0.1%
        
        # –°—Ç–æ–ø-–ª–æ—Å—Å - –ø–æ–¥ –ª–æ–∫–∞–ª—å–Ω—ã–º –º–∏–Ω–∏–º—É–º–æ–º
        stop_loss = setup_info['local_low'] - (setup_info['local_low'] * 0.002)  # -0.2%
        
        # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å—Ç–æ–ø-–ª–æ—Å—Å - –ø–æ–¥ EMA33
        alt_stop_loss = setup_info['ema_at_low'] - (setup_info['ema_at_low'] * 0.005)  # -0.5%
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π (–≤—ã—à–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã–π) —Å—Ç–æ–ø-–ª–æ—Å—Å
        stop_loss = max(stop_loss, alt_stop_loss)
        
        # –†–∞—Å—á–µ—Ç —Ä–∏—Å–∫–∞
        risk_distance = entry_price - stop_loss
        
        # Take Profit —É—Ä–æ–≤–Ω–∏
        tp1 = entry_price + risk_distance * 1.0  # R/R 1:1
        tp2 = entry_price + risk_distance * 2.0  # R/R 1:2
        tp3 = entry_price + risk_distance * 3.0  # R/R 1:3
        
        return Signal(
            symbol=ticker,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit_1=tp1,
            take_profit_2=tp2,
            take_profit_3=tp3,
            signal_time=datetime.now(),
            setup_description="EMA33 breakout + Local High/Low formation",
            risk_reward_1=1.0,
            risk_reward_2=2.0,
            risk_reward_3=3.0,
            local_high=setup_info['local_high'],
            local_low=setup_info['local_low']
        )

    def format_signal_message(self, signal: Signal) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Å–∏–≥–Ω–∞–ª–æ–º"""
        risk_amount = signal.entry_price - signal.stop_loss
        
        message = f"""
üöÄ <b>–ù–û–í–´–ô –°–ò–ì–ù–ê–õ</b>

üìä <b>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç:</b> {signal.symbol}
‚è∞ <b>–í—Ä–µ–º—è:</b> {signal.signal_time.strftime('%H:%M:%S %d.%m.%Y')}

üí° <b>–°–µ—Ç–∞–ø:</b> {signal.setup_description}
üìà <b>–õ–æ–∫–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º:</b> {signal.local_high:.2f} ‚ÇΩ
üìâ <b>–õ–æ–∫–∞–ª—å–Ω—ã–π –º–∏–Ω–∏–º—É–º:</b> {signal.local_low:.2f} ‚ÇΩ

üìà <b>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–¥–µ–ª–∫–∏:</b>
üéØ <b>–í—Ö–æ–¥ (–ª–∏–º–∏—Ç–Ω—ã–π –æ—Ä–¥–µ—Ä):</b> {signal.entry_price:.2f} ‚ÇΩ
üõë <b>Stop Loss:</b> {signal.stop_loss:.2f} ‚ÇΩ
üí∞ <b>–†–∏—Å–∫:</b> {risk_amount:.2f} ‚ÇΩ ({(risk_amount/signal.entry_price*100):.1f}%)

üéØ <b>Take Profit:</b>
‚Ä¢ <b>TP1 (1/3):</b> {signal.take_profit_1:.2f} ‚ÇΩ | R/R: 1:1
‚Ä¢ <b>TP2 (1/3):</b> {signal.take_profit_2:.2f} ‚ÇΩ | R/R: 1:2
‚Ä¢ <b>TP3 (1/3):</b> {signal.take_profit_3:.2f} ‚ÇΩ | R/R: 1:3

üìã <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–µ–π:</b>
1Ô∏è‚É£ –ü—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ TP1 ‚Üí –∑–∞–∫—Ä—ã—Ç—å 1/3 + SL –≤ –±–µ–∑—É–±—ã—Ç–æ–∫
2Ô∏è‚É£ –ü—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ TP2 ‚Üí –∑–∞–∫—Ä—ã—Ç—å 1/3 + SL –Ω–∞ —É—Ä–æ–≤–µ–Ω—å TP1
3Ô∏è‚É£ –ü—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ TP3 ‚Üí –∑–∞–∫—Ä—ã—Ç—å –æ—Å—Ç–∞—Ç–æ–∫

#TradingSignal #{signal.symbol}
        """
        return message.strip()

    async def scan_instruments(self):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –Ω–∞ —Å–∏–≥–Ω–∞–ª—ã"""
        signals_found = 0
        
        for ticker in TOP_MOEX_STOCKS:
            try:
                if ticker not in self.instruments_cache:
                    continue
                    
                figi = self.instruments_cache[ticker]
                
                # –ü–æ–ª—É—á–∞–µ–º 1-—á–∞—Å–æ–≤—ã–µ —Å–≤–µ—á–∏ –∑–∞ 7 –¥–Ω–µ–π (—É–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –ª—É—á—à–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞)
                df = await self.get_candles(figi, CandleInterval.CANDLE_INTERVAL_HOUR, days=7)
                
                if df.empty or len(df) < 50:
                    continue
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–±–æ—è EMA33
                if ticker not in self.ema_breakouts:
                    breakout_info = self.detect_ema_breakout(df)
                    if breakout_info:
                        self.ema_breakouts[ticker] = {
                            'time': breakout_info['time'],
                            'price': breakout_info['price'],
                            'index': breakout_info['index']
                        }
                        logger.info(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω –ø—Ä–æ–±–æ–π EMA33 –¥–ª—è {ticker} @ {breakout_info['price']:.2f}")
                        
                        # –£–≤–µ–¥–æ–º–ª—è–µ–º –æ –ø—Ä–æ–±–æ–µ
                        message = f"""
üìç <b>–ü—Ä–æ–±–æ–π EMA33!</b>

üìä <b>{ticker}</b>
üí∞ –¶–µ–Ω–∞ –ø—Ä–æ–±–æ—è: {breakout_info['price']:.2f} ‚ÇΩ
‚è∞ –í—Ä–µ–º—è: {breakout_info['time'].strftime('%H:%M')}

–û—Ç—Å–ª–µ–∂–∏–≤–∞—é —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–∞–ø–∞...
                        """
                        await self.broadcast_message(message.strip())
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–∞–ø–∞ –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å –ø—Ä–æ–±–æ–µ–º
                if ticker in self.ema_breakouts and ticker not in self.active_signals:
                    breakout_data = self.ema_breakouts[ticker]
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–ª–∏—à–∫–æ–º –ª–∏ —Å—Ç–∞—Ä—ã–π –ø—Ä–æ–±–æ–π (–º–∞–∫—Å–∏–º—É–º 48 —á–∞—Å–æ–≤)
                    time_since_breakout = datetime.now() - breakout_data['time']
                    if time_since_breakout > timedelta(hours=48):
                        del self.ema_breakouts[ticker]
                        logger.info(f"–£–¥–∞–ª–µ–Ω —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –ø—Ä–æ–±–æ–π –¥–ª—è {ticker}")
                        continue
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
                    setup_info = self.check_setup_formation(df, breakout_data)
                    
                    if setup_info:
                        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —ç–∫—Å—Ç—Ä–µ–º—É–º–∞—Ö
                        self.ema_breakouts[ticker]['local_high'] = setup_info['local_high']
                        self.ema_breakouts[ticker]['local_low'] = setup_info['local_low']
                        
                        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª
                        signal = self.generate_signal(ticker, setup_info)
                        
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞
                        if signal.entry_price > setup_info['current_price']:
                            self.active_signals[ticker] = signal
                            message = self.format_signal_message(signal)
                            await self.broadcast_message(message)
                            signals_found += 1
                            logger.info(f"–ù–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª: {ticker} @ {signal.entry_price:.2f}")
                            
                            # –£–¥–∞–ª—è–µ–º –∏–∑ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–±–æ–µ–≤
                            del self.ema_breakouts[ticker]
                    
                await asyncio.sleep(0.5)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è {ticker}: {e}")
                continue
                
        if signals_found > 0:
            logger.info(f"–ù–∞–π–¥–µ–Ω–æ –Ω–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤: {signals_found}")

    async def monitor_active_signals(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
        for ticker, signal in list(self.active_signals.items()):
            try:
                if ticker not in self.instruments_cache:
                    continue
                    
                figi = self.instruments_cache[ticker]
                df = await self.get_candles(figi, CandleInterval.CANDLE_INTERVAL_1_MIN, days=1)
                
                if df.empty:
                    continue
                    
                current_price = df['close'].iloc[-1]
                high_price = df['high'].iloc[-1]
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞
                if high_price >= signal.entry_price and not hasattr(signal, 'triggered'):
                    signal.triggered = True
                    message = f"""
üî• <b>–°–ò–ì–ù–ê–õ –°–†–ê–ë–û–¢–ê–õ!</b>

üìä <b>{signal.symbol}</b>
üí∞ <b>–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞:</b> {signal.entry_price:.2f} ‚ÇΩ
üìà <b>–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞:</b> {current_price:.2f} ‚ÇΩ

–ü–æ–∑–∏—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∞! –°–ª–µ–¥–∏—Ç–µ –∑–∞ —É—Ä–æ–≤–Ω—è–º–∏ TP –∏ SL.
                    """
                    await self.broadcast_message(message.strip())
                    
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ TP —É—Ä–æ–≤–Ω–µ–π (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å—Ä–∞–±–æ—Ç–∞–≤—à–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤)
                if hasattr(signal, 'triggered'):
                    # TP1
                    if current_price >= signal.take_profit_1 and not hasattr(signal, 'tp1_reached'):
                        signal.tp1_reached = True
